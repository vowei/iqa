林曙勇先生，你好！

正如私信里跟你讲的那样，我设计iqa的初衷就是实现“需求即模型”的想法。这里先说一下当前iqa能够实现的功能：

1. 通过代码模板的方式生成不同编程语言的测试用例，如下面一个iqa用例：

   场景: 一个演示用场景
   * 测试的第一个步骤
   * 测试的第二个步骤

   如果用户输入一个代码模板，如一个junit代码模板：https://github.com/vowei/iqa/blob/master/src/cc/iqa/iQAMobileJUnit.stg，就会生成类似下面的junit代码：
   public class 具有缩进编写方式的功能 extends iQATestBase {
      // ...
 
      public void test一个演示用场景() throws Exception
      {
          AutomationContext context = this.getContainer().getComponent(AutomationContext.class);
          Hashtable<String, Object> resolver = null;
          Hashtable<String, Object> variables = new Hashtable<String, Object>();
          this.S("测试的第一个步骤");
          this.S("测试的第二个步骤");
      }
   
      public class ControlNameMap { ... }
   }

   而如果采用apple javascript的代码模板，如：https://github.com/vowei/iqa/blob/master/src/cc/iqa/iQAMobileApple.stg，则就会生成类似下面的javascript代码：
       // ...
       this.test一个演示用场景 = function() {
           var scenarioInfo = {
               "title": 一个演示用场景
           };
           testRunner.ScenarioSetup(scenarioInfo);
 
           testRunner.Step("测试的第一个步骤");
           testRunner.Step("测试的第二个步骤");
           testRunner.ScenarioCleanup();
       }

2. 支持变量的解析，以及表示式处理，因为iqa支持中文，因此变量采用的形式是包含在中括号里的字符就是变量，如 [变量]、[变量名　可以　有空格]。基本的表达式（也可以跟普通编程语言一样赋值一个函数）如：
   [结果] = [变量1] + [变量2]
   [函数变量] = * 测试的第一个步骤

3. 支持条件判断、循环等语句，如：
   当 [开盘时间] 
       * 测试买卖股票
   否则
       * 测试其他功能

4. 支持函数的功能，实际上就是测试场景之间可以相互调用。

5. iqa编译器本身可以用java、python、C#等多种编程语言编写。

那通过iqa实现模型驱动的想法是这样的，首先，如BDD一样，每个测试步骤都是一个函数，执行具体的测试逻辑。由于iqa可以解析表达式，所以就可以获知变量之间的依赖关系，如下面的表达式，就表明变量 [结果] 依赖于 [变量1] 和 [变量2]
[结果] = [变量1] + [变量2]

而通过类似函数一样的，测试场景之间相互调用，以及表达式跟步骤地关系，就可以知道两个相互依赖的变量是如何更新、关联的，如下面的用例（语法跟当前的iqa语法还不一样，只是演示我的想法，现在要做的就是把下面这种建模过程尽量容易直观）：

场景: 验证账户资金不能为负
* 买卖股票并盈利
* 买卖股票并亏损

场景: 买卖股票并盈利
* 购入[股票]共100股
  [成本] = 100 * [股票.价格]
* 售出[股票]共100股
  [销售额] = 100 * [股票.价格]
* [盈利] = [销售额] - [成本]
* 验证 [盈利] >= 0

场景: 买卖股票并亏损

经过编译器分析，可以得知，变量间的依赖关系：[盈利] /--- 依赖于 -> [销售额] -- 依赖于 ->  [股票.价格] 
                                                   \___ 依赖于 -> [成本]   -- 依赖于 /

上面的依赖关系里 [盈利] 已经依赖其他变量，暂时不提，而变量 [销售额] 和 [成本] 的修改方式为：

验证账户资金不能为负 -- 调用 --> 买卖股票并盈利 -- 调用 --> 购入[股票]共100股 -- 修改 --> [成本]
验证账户资金不能为负 -- 调用 --> 买卖股票并盈利 -- 调用 --> 售出[股票]共100股 -- 修改 --> [销售额]

这样编译器通过分析变量与测试步骤之间的关系，就相当于知道一个模型，应该可以生成一些用例了，但是这里还缺了一些东西，如 [股票] 和 [股票.价格] 这两个内容在上面都没有提。这是因为其是两个测试外部变量，如  [股票]  是数据测试驱动试，通过外部配置文件读入的值；而 [股票.价格] 又是要根据 [股票] 的值，在待测程序界面上读取的实时价格，而从界面上读取某个控件的内容的工作就是iquery来做的，iquery类似jquery，就是通过一个类似css selector的语法在一个控件树上定位某个或者一群控件集合。

在最上面的junit测试代码里，里面有一个ControlNameMap内嵌类，就是用来做这个事情的，如测试用例源码里可以将变量  [股票.价格]  的 [股票] 提取出来获取股票的具体值，然后再通过ControlNameMap获取 [股票.价格] 对应的iquery语句找到控件并读取指定股票的价格。

之所以要这么设计，是因为我觉得，因为测试场景间可以相互调用，用户在提供需求的时候，可以提一个比较泛的需求；然后由测试人员通过补充测试步骤和对应的场景的方式，一方面细化需求，一方面就直接是测试用例了。当细化到一定程度，并包含了变量之间依赖关系，以及变量与测试步骤之间的联系后，就可以将它作为模型开始生成用例了。

现在还仅仅是设想阶段，需要请你这样的模型驱动测试专家来评审下可行性，而且还有些地方没有想透，例如根据某些变量的值，禁用或启用一些场景的语法还没有想清楚，也需要想你这样的专家来帮忙出主意。


-----------------------------------------------------------------------------------------------------------------------------------------------------

在 2013年1月16日上午12:18，林曙勇 写道：
hi,
   你好，谢谢你的来信，根据你的问题，我尝试说一下我的理解。
   第一点，关于需求及模型。
   现在一般提的比较多的是“需求即测试用例”，意思是说如果我们采用ATDD/BDD之类的开发方式，如果能够比较好的贯彻测试先行的方式，测试用例的可读性，准确性都能达到一定的要求的话，测试用例本身可以当作需求文档的作用。
   我比较认可你的观点，“测试场景间可以相互调用，用户在提供需求的时候，可以提一个比较泛的需求；然后由测试人员通过补充测试步骤和对应的场景的方式，一方面细化需求，一方面就直接是测试用例了”，但是对于你提出的 “需求即模型”的说法，还不是有特别清晰的概念。
   在我们的实践中，MBT主要用来捕捉一些常规的需求分析/测试设计比较难以覆盖的问题。但是在需求分析的最初，就引入模型的概念，我不确定是不是一个好的做法。在软件开发的一开始，我比较认可ATDD/User Story这种更多地鼓励业务代表，测试，开发充分沟通的方式。如果一开始就强调模型，也许会不利于进行充分的沟通？
  但在功能逐渐成形之后，往往会发现ATDD Case测试设计上的疏漏，这个时候可以引进更多的测试手段，比如MBT是一种值得考虑的做法。

   第二点，：
   如果你是想实现中文编程的话，其实Robot Framework也是可以做到的。
    我附了一个例子，是可以直接用Robot的命令执行的。我也附上了log，供参考。
个人建议还是可以先看一下它是否可以满足你的要求，再决定是否要重新开发一个新的Framework，毕竟一个东西从概念，到雏形，到能用，再到好用，中间付出的劳动还是很大的。
http://code.google.com/p/robotframework/ 。

   如有理解不到位的地方，还请指正。谢谢。
林曙湧

-----------------------------------------------------------------------------------------------------------------------------------------------------

在 2013年1月17日下午5:31，Shi Yimin 写道：
林先生，你好

iqa的目标不是使用中文编程，cucumber已经可以使用中文编写BDD测试用例了，因此重复造轮子没有意义。其实我不是很赞同“需求就测试用例”的概念，我觉得开发任务和测试用例都是从需求衍生出来的，因此我更倾向于“需求即模型的概念”；而且一般客户描述需求的时候都不会很清晰，需求分解的时候，一般也只是分解到一定程度就会停止了，不会细到具体的测试用例级别。

比如说：“买黄金T+D的保证金需要合理”这个需求，就可以衍生出“保证金为0的场景”，“保证金在初始时余额足够，但收盘时因为亏损导致不足”，“保证金在初始时余额不足，但是第一天盈利、第二天又亏损再次不足”等种种场景。

现有的几个建模工具，如NModel等，因为是使用C#等编程语言描述，造成建模很困难，而robot framework编写的测试用例不是很直观。

我之所以想开发iqa这个轮子，就是想让模型驱动测试的建模过程变得简单直观，模型是直接使用用户的语言描述，但是又能达到建模的效果。这一块我承认如何实现这个目标尚不是很清楚，我需要再想想。

最后，对于画User Story的描述需求的方式，我也持一些怀疑态度，我自己也画过类似的图，这种图的问题是：画图需要有一定的功底，另外用户是否理解User Story图也有待商榷。

谢谢
施懿民

-----------------------------------------------------------------------------------------------------------------------------------------------------3

在 2013年1月17日下午9:09，林曙勇 写道：
hi, 你好
     在我看来，测试模型是对具体测试用例的抽象，应该是已经有很多具体的测试想法之后，再对这些想法加以分类归纳，抓住其中的本质，提炼出模型。
    用户提的需求都是一些比较粗的点，不能直接用于开发，需要做一些细化提炼。在我们的实践中，会细化到测试用例的测什么的级别，然后在一个迭代中并行开发产品代码和自动化测试用例（怎么测），所谓的测试驱动开发。
   在你没有搞清楚测什么的时候，通常你也没有想好代码到底要实现什么功能。
    你举的关于保证金的例子，我理解这里面是有一个挺清晰的状态机模型的，比如账户余额的不同状态以及状态之间的跃迁。
     但未必所有的软件都是这种应用模式的。另外，哪怕是在这种状态比较清晰的情况下，在explore 用户的需求的时候，太早提出模型，会不会有点操之过急，反而会漏掉一些隐性需求？
     MBT的复杂性来自于两方面，一方面是模型本身的复杂性，另外一块是工具使用上的门槛。
     如果用自然语言就能实现模型的话，可能可以降低工具使用的门槛，但应该不能解决模型本身的复杂性的问题。
      模型本身是抽象的，你的想法可能是让用户从具体的需求可以比较自然地过渡到一个抽象的模型。如果模型用编程语言实现的话，从具体的需求到抽象的模型可能会存在一个比较明显的跳跃。
       但是用了自然语言的话，是否这个跳跃就不存在了呢？
       比如说我们一开始会描述说，
    我们需要一个交通工具，有四个轮子，四扇门，里面还有1个3人沙发，2个单人沙发，还有圆圆的可以控制方向的装置......

   但后来发现，这样描述还是太费劲，所以可能会给它做一个抽象叫做车，这样就实现了从具体需求到抽象概念的飞跃。
   我怀疑用了自然语言，这种飞跃还是会存在的。
另外User Story是不用画图的，这个可能理解上不太对。
    谢谢。
  林曙湧

-----------------------------------------------------------------------------------------------------------------------------------------------------

在 2013年1月27日下午11:30，Shi Yimin <shiyimin.aaron@gmail.com>写道：
林曙勇，你好

非常抱歉，这些天公司繁琐的事情非常多，一直抽不出时间来回复你的邮件，请看我在你邮件里的回复。最后冒昧问一句，我们的邮件讨论是否可以放在网上公开，以便更多的人参与进来讨论？

谢谢
施懿民

在 2013年1月17日下午9:09，林曙勇 写道：
hi, 你好
     在我看来，测试模型是对具体测试用例的抽象，应该是已经有很多具体的测试想法之后，再对这些想法加以分类归纳，抓住其中的本质，提炼出模型。
[懿民] 这一点我的观点是一半对一半，的确，是应该需要有很多具体的做法之后，才能归纳总结出规律。但并不意味着一定要等到系统开发过程中，写了很多测试用例之后才能建模。很多系统都是针对相似问题的不同甚至是反复的解决方案，因此在系统研发出来之前建好模型是可行的。

模型应该也是可以逐步演化的，举个可能不恰当的例子，在飞机造出来之前，不应该还是要将飞机的模型放在风洞里测试一下的吗？举个很简化的例子，比如说登录系统，在系统实现之前，应该就知道需要登录名和密钥，一开始模型可以简单点。但是到了向银行这些大型企业，内部集成了很多不同厂商，不同技术的系统，需要单点登录，即使其登录方式各不相同（如使用智能卡、用户名/密码、域认证等），还是可以通过细化登录系统的简单模型开始，逐步演化的。 

我不少的想法都是从看这本书来的：Model-based Software Testing and Analysis with C#， 其就是介绍nmodel使用以及原理的一本书。

总的来说，我认为先建模型是一个可行，而且更合适的开发、测试方法。
 
    用户提的需求都是一些比较粗的点，不能直接用于开发，需要做一些细化提炼。在我们的实践中，会细化到测试用例的测什么的级别，然后在一个迭代中并行开发产品代码和自动化测试用例（怎么测），所谓的测试驱动开发。
[懿民] 测试驱动开发我自己也正在做，我的实践中，一般是先看看需求，然后先写自动化测试用例 - 虽然是一个单元级别的测试用例，但一般我不会做到每个函数都测试那么细节，只是演示类型之间，各个函数之间如何相互调用，调用顺序如何，可以理解成API级别的使用场景，再补齐空函数，再在空函数里写注释，最后实现代码。这种方式，主要是向其他组件的开发人员定义我对外的接口，或者定义我对所依赖的组件要求的接口，数据结构等等。

对于有界面的应用，我现在的做法是先做UI，采用MVC/MVVM等设计模式，先是建立伪造的模型对象，然后通过restful api或者web service调用，定义restful/web service接口，反向实现程序。我认为这样的编码方式更有效率，因为一开始整个团队就知道UI工作流，数据流，避免后期整合的麻烦。

   在你没有搞清楚测什么的时候，通常你也没有想好代码到底要实现什么功能。
[懿民] 这一点我同意，因此我倾向于反向实现代码。
 
    你举的关于保证金的例子，我理解这里面是有一个挺清晰的状态机模型的，比如账户余额的不同状态以及状态之间的跃迁。
     但未必所有的软件都是这种应用模式的。另外，哪怕是在这种状态比较清晰的情况下，在explore 用户的需求的时候，太早提出模型，会不会有点操之过急，反而会漏掉一些隐性需求？
[懿民] 我的意思不是急于提出模型，而是希望实现从需求 -> 粗略模型 -> 细化的模型 -> 测试（UI）驱动开发。希望能够实现从需求到模型、到代码、到测试用例之间双向联系。因此如果用户希望改变需求的时候，通过修改或评估需求可以快速到达模型、代码、测试用例。
 
     MBT的复杂性来自于两方面，一方面是模型本身的复杂性，另外一块是工具使用上的门槛。
     如果用自然语言就能实现模型的话，可能可以降低工具使用的门槛，但应该不能解决模型本身的复杂性的问题。
[懿民] 使用自然语言建模，降低模型驱动测试的门槛是我的愿景，虽然我还没有明白怎么做。
 
      模型本身是抽象的，你的想法可能是让用户从具体的需求可以比较自然地过渡到一个抽象的模型。如果模型用编程语言实现的话，从具体的需求到抽象的模型可能会存在一个比较明显的跳跃。
       但是用了自然语言的话，是否这个跳跃就不存在了呢？
[懿民] 人们常说一图胜千言，既表明了图的总结能力，同时也隐含了画图所需的总结和表现能力。虽然文字一开始会不清晰，但是随着大家对系统的理解的深入，文字会越来越清晰丰富，（我觉得）从而更好建模。
 
       比如说我们一开始会描述说，
    我们需要一个交通工具，有四个轮子，四扇门，里面还有1个3人沙发，2个单人沙发，还有圆圆的可以控制方向的装置......

   但后来发现，这样描述还是太费劲，所以可能会给它做一个抽象叫做车，这样就实现了从具体需求到抽象概念的飞跃。
[懿民] 或者反过来说，车是不是就是一个很好的模型呢？“车”是一个粗略的模型，然后有4个“轮子”模型，四扇“门”模型等等。
 
   我怀疑用了自然语言，这种飞跃还是会存在的。
另外User Story是不用画图的，这个可能理解上不太对。
[懿民] 我理解成UML里的User Story图了，如果不用画图，我也在想，是不是可以从User Story总结和提取模型呢？
 
    谢谢。
  林曙湧


-----------------------------------------------------------------------------------------------------------------------------------------------------

在 2013年2月16日下午2:15，林曙勇 写道：
hi,
    不好意思，年前比较忙，所以直到今天才看到这封信。
     原文比较长，我就不一一回复了，说一下我的想法，供参考。
     我觉得我们讨论到了一些类似基于模型的开发的话题，比如你举的飞机模型的例子。 但其实对于这个话题，我其实并没有太多的经验。我对于ATDD相关的话题关注得比较多，也是因为我们公司这边主要是在采用这种方式来做开发。所以对ATDD和MDD来做比较，讨论优劣，可能我并没有足够的积累来讨论这个问题。
      我知道Model Driven Development 也是在业界被深入研究过的话题，应该和UML等技术比较相关一些。但是我们其实也没有采用UML这套开发技术，所以我对UML的理解也是比较肤浅的。
      只是了解到一些之前在UML领域非常有名的专家，之后都转向敏捷领域的一些开发方式了（ATDD/TDD)等，而且据我所知，MDD并没有大规模的推广开来，可能是因为它本身还存在一些问题吧。
  在ATDD里面，一般是这样的流程
      User Story -->拆分过的User Story---> Acceptance Case--->驱动开发
      我们一般建议Acceptance Case 应该尽可能有一些具体的例子来描述，甚至越具体越好，不是很推荐用抽象的方式来描述，以避免Business User 和开发团队之间的误解。
       而基于模型的测试，一般是一些较为抽象的规则描述，然后通过一些数学模型生成一组我们想要的case。
       我不知道这两者是不是很容易统一起来，感觉有些难，但也许在某些时候也是可以统一起来，但应该不是所有的情况都一样。这方面，我也需要更多的思考。
    另外，如果有人愿意参与一起讨论的话，应该也是很不错的，不知道你会考虑放在哪里呢？
BR,
Shuyong
